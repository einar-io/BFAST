\section{Einar's part}

\begin{frame}[fragile]{Overview}
\begin{enumerate}
    \item Setting the baseline clear.
    \item \texttt{scan}
    \item \texttt{bfast\_step\_5}
    \item \texttt{bfast\_step\_6} Aske Dorge's rule of thumb for shared
        memory and its impact.
\end{enumerate}
    \pause
Questions are appreciated during and after the presentation :)
\end{frame}


\begin{frame}[fragile]{Baseline}

The baseline: \mint{bash}|make benchmark-naive|
\end{frame}

\begin{frame}[fragile]{Baseline}
    \centering
    \begin{minted}{text}
bfast-naive (all times are an average of 500 runs):

bfast_step_1_run         12.25 µs
transpose_X              11.86 µs
bfast_step_2_run      23678.14 µs
bfast_step_3_run       2648.65 µs
transpose_Y            1212.03 µs
bfast_step_4a_run      1265.11 µs
untranspose_beta0        77.18 µs
bfast_step_4b_run       507.25 µs
transpose_beta           75.39 µs
bfast_step_4c_run      3981.45 µs
untranspose_y_preds    1209.31 µs
bfast_step_5_run       2910.24 µs
bfast_step_6_run       2475.36 µs
bfast_step_7a_run       480.90 µs
bfast_step_7b_run        11.07 µs
bfast_step_8_run       6869.04 µs


Total runtime         47425.22 µs
\end{minted}

\end{frame}

\begin{frame}[fragile]{Baseline}
%
%The missing baseline: \mint{bash}|make benchmark-naive|
    \centering
    \begin{minted}[escapeinside=||]{text}
bfast-naive (all times are an average of 500 runs):

bfast_step_1_run         12.25 µs
transpose_X              11.86 µs
bfast_step_2_run     |\colorbox{teal}{23678.14 µs}|
bfast_step_3_run       2648.65 µs
transpose_Y            1212.03 µs
bfast_step_4a_run      1265.11 µs
untranspose_beta0        77.18 µs
bfast_step_4b_run       507.25 µs
transpose_beta           75.39 µs
bfast_step_4c_run     |\colorbox{teal}{3981.45 µs}|
untranspose_y_preds    1209.31 µs
bfast_step_5_run       2910.24 µs
bfast_step_6_run       2475.36 µs
bfast_step_7a_run       480.90 µs
bfast_step_7b_run        11.07 µs
bfast_step_8_run      |\colorbox{teal}{6869.04 µs}|


Total runtime         47425.22 µs
\end{minted}

\pause

We need to keep this in mind to appreciate the optimized kernels:

\end{frame}

\begin{frame}[fragile]{Optimizations}

    %..the optimized kernels: \mint{bash}|make benchmark|

\centering
\begin{minted}{text}
bfast-opt (all times are an average of 500 runs):

bfast_step_1_run             12.33 µs
transpose_X                  11.74 µs
transpose_Y                1226.57 µs
bfast_step_2_tiled_run     2684.43 µs
bfast_step_3_run           2609.89 µs
bfast_step_4a_tiled_run     708.69 µs
untranspose_beta0            76.95 µs
bfast_step_4b_run           501.44 µs
bfast_step_4c_tiled_run    1002.97 µs
bfast_step_5_run           2878.34 µs
bfast_step_6_reuse_run     1981.08 µs
bfast_step_7a_run           474.89 µs
bfast_step_7b_run            10.88 µs
bfast_step_8_opt2_run      1722.23 µs


Total runtime             15902.44 µs
\end{minted}

\pause
Achieved by applying optimizations:
\(\frac{47425.22}{15902.44} = 2.98 \times \) speed-up.



\end{frame}


\section{\texttt{bfast\_step\_5}} % Einar

% Et af de argumenter, der bruges til at støtte udviklingen af autonome
% våbensystemer, påpeger at autonome våbensystemer vil være i stand til at undgå
% nogle af de fejl, mennesker begår, og derfor vil autonome våbensystemer på
% sigt være med til at nedbringe antallet af civile ofre i krig. Beskriv Peter
% Asaros holdning til argumentet og diskuter, om I selv finder argumentet
% holdbart.

\begin{frame}[fragile]{Futhark}

%  -- Cosmin's tip for this bit: Assume N < 1024
%
%  ---------------------------------------------
%  -- 5. filter etc.                          --
%  ---------------------------------------------
%  -- Nss:        Nss[i] where 0<=i<m is the number of valid (non-NaN) entries
%  --             for time series i
%  -- y_errors:   y_errors[i] where 0<=i<m is an array of error values for time
%  --             series i, partitioned such that valid (non-NaN) entries come
%  --             before invalid (NaN) entries.
%  -- vald_indss: vald_indss[i] where 0<=i<m is an array of indices indicating
%  --             the original positions of the elements in y_errors[i], i.e.,
%  --             before partitioning.
\begin{minted}{haskell}
let (Nss, y_errors, val_indss) =
unsafe ( intrinsics.opaque <| unzip3 <|
  map2 (\y y_pred ->
    let y_error_all = zip y y_pred |>
    F
      map (\(ye,yep) -> if !(f32.isnan ye) 
                        then ye-yep 
                        else f32.nan )
    let (tups, Ns) = zip2 y_error_all (iota N) |>
      partitionCos (\(ye,_) -> !(f32.isnan ye)) (0.0, 0)
    let (y_error, val_inds) = unzip tups
    in  (Ns, y_error, val_inds)
      ) images y_preds )
\end{minted}

\end{frame}

\begin{frame}[fragile]{CUDA}

\begin{minted}{cuda}
void bfast_step_5_run(struct bfast_state *s)
{
  /* .. */
  dim3 block(N, 1, 1);
  dim3 grid(m, 1, 1);
  const size_t shared_size = N * sizeof(int);
  bfast_step_5<<<grid, block, shared_size>>>
    (d_Y, d_y_preds, d_Nss, d_y_errors,
    d_val_indss, N);
\end{minted}

\end{frame}

\section{\texttt{bfast\_step\_6}} 

\begin{frame}[fragile]{CUDA}

\begin{minted}{cuda}
__global__ void bfast_step_6_reuse(float *Yh, float *y_errors, int *nss,
    float *sigmas, int n, int N, int k2p2)
{
  /* .. */
  __shared__ int num_valids[1024];
  num_valids[threadIdx.x] = !isnan(yh[threadIdx.x]);
  __syncthreads();
  scaninc_block_add<int>(num_valids);
  int ns = num_valids[n - 1];
  __syncthreads(); // necessary because shared memory is reused

  //sizeof{int} == sizeof{float}
  float *sigma_shared = (float *) num_valids; // Here be dragons
  float val = threadIdx.x < ns ? y_error[threadIdx.x] : 0.0;
  val = val * val;
  sigma_shared[threadIdx.x] = val;
  __syncthreads();
  scaninc_block_add<float>(sigma_shared);

  if (threadIdx.x == 0) {
    sigmas[blockIdx.x] =
      __fsqrt_rd(sigma_shared[n - 1] / ((float)(ns - k2p2)));
    nss[blockIdx.x] = ns;
  }
}
\end{minted}
\pause
\mint{cuda}|sizeof{int} == sizeof{float}|

\end{frame}

\begin{frame}[fragile]{Launch parameters}
\begin{minted}{cuda}
void bfast_step_6_reuse_run(struct bfast_state *s)
{
  /* .. */
  dim3 grid(m, 1, 1);
  dim3 block(n, 1, 1);
  bfast_step_6_reuse<<<grid, block>>>
    (d_Y, d_y_errors, d_nss, d_sigmas, n, N, k2p2);
}

\end{minted}
\end{frame}


\section{\texttt{scan}} 

\begin{frame}[fragile]{\texttt{scan}}
\begin{minted}{cuda}
template <class T>
__device__ inline T scaninc_block_add_nowrite(volatile T *in)
{
  const unsigned int idx    = threadIdx.x;
  const unsigned int lane   = idx &  31;
  const unsigned int warpid = idx >> 5;

  T val = scaninc_warp_add(in);
  __syncthreads();

  if (lane == 31) { in[warpid] = val; }
  __syncthreads();

  if (warpid == 0) scaninc_warp_add(in);
  __syncthreads();

  if (warpid > 0) {
    val = in[warpid-1] + val;
  }

  return val;
}
\end{minted}
\end{frame}


\begin{frame}[fragile]{\texttt{scan}}
\begin{minted}{cuda}
template <class T>
__device__ inline T scaninc_block_add_nowrite(volatile T *in)
{
  const unsigned int idx    = threadIdx.x;
  const unsigned int lane   = idx &  31;
  const unsigned int warpid = idx >> 5;

  T val = scaninc_warp_add(in);
  __syncthreads();

  if (lane == 31) { in[warpid] = val; }
  __syncthreads();

  if (warpid == 0) scaninc_warp_add(in);
  __syncthreads();

  if (warpid > 0) {
    val = in[warpid-1] + val;
  }

  return val;
}

template <class T>
__device__ inline void scaninc_block_add(volatile T *in)
{
  const unsigned int idx = threadIdx.x;
  T val = scaninc_block_add_nowrite(in);
  __syncthreads();
  in[idx] = val;
  __syncthreads();
}
\end{minted}
\end{frame}

\begin{frame}[fragile]{\texttt{scan\_block\_add\_nowrite} or \texttt{reduce}}

    \begin{table}
        \centering
        \begin{tabular}{l r}
            \textbf{Kernel} & \textbf{Average running time} \\ \hline
            \textbf{bfast\_step\_6\_reuse\_run} &     2135.66 µs \\
            \textbf{bfast\_step\_6\_reuse\_run (no\_write)} &    2087.66 µs
        \end{tabular}
        \caption{Measurements are averages over 500 runs.}
        \label{tab:nowrite}
    \end{table}

\end{frame}

\begin{frame}[fragile]{Work-Depth of scan \texttt{scan}}

    \begin{enumerate}
        \item [Work Complexity W(n)] is the total \# of ops performed,
        \item [Depth/Step Complexity D(n)] is the \# of sequential steps.
    \end{enumerate}

\end{frame}
